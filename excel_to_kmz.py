#!/usr/bin/env python3
"""
excel_to_kmz.py

Create a KMZ (KML zipped) from an Excel/CSV file produced by this pipeline.

Goals
- Allow the Excel template generated by the KMZ parser to act as a standalone
  entry point for reconstructing a KMZ when the original KMZ is unavailable.
- Be robust to header variations by using the same normalization strategy used
  in the API (aliases for common column names).

Usage
  python excel_to_kmz.py input.xlsx -o output/kmz_from_excel.kmz [--polygon polygon.txt]

Notes
- The script reads latitude/longitude from the sheet and emits placemarks.
- If a polygon file is provided (a text file with one coordinate pair per line),
  it is added as a Polygon overlay to the KML.
- The script is idempotent and only writes within the given output path.
"""

from __future__ import annotations

import argparse
import csv
import io
import math
import sys
import zipfile
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple

try:
    import pandas as pd  # type: ignore
except Exception as e:  # pragma: no cover - pandas is required by project already
    print("pandas is required: pip install pandas", file=sys.stderr)
    raise


# Canonical column names used across the pipeline
CANON_NAME = "Site Name or Business Name "
CANON_LAT = "Latitude (NAD83)"
CANON_LON = "Longitude (NAD83)"
CANON_CAPACITY = "Tank Capacity"
CANON_MEASUREMENTS = "Tank Measurements"
CANON_NOTES = "Additional information "
CANON_CONTACT = "Person Contacted"


def _norm_header(h: str) -> str:
    import re
    s = (h or "").strip().lower()
    return re.sub(r"[^a-z0-9]+", "", s)


# Header alias map inspired by api/main.py
HEADER_ALIASES: Dict[str, str] = {
    # Name
    "sitenameorbusinessname": CANON_NAME,
    "sitename": CANON_NAME,
    "businessname": CANON_NAME,
    "name": CANON_NAME,
    "facilityname": CANON_NAME,
    # Coordinates
    "latitude": CANON_LAT,
    "lat": CANON_LAT,
    "latitude(nad83)": CANON_LAT,
    "longitude": CANON_LON,
    "long": CANON_LON,
    "lon": CANON_LON,
    "longitude(nad83)": CANON_LON,
    # Helpful extras
    "tankcapacity": CANON_CAPACITY,
    "capacity": CANON_CAPACITY,
    "tankmeasurements": CANON_MEASUREMENTS,
    "additionalinformation": CANON_NOTES,
    "personcontacted": CANON_CONTACT,
}


def resolve_columns(df_columns: Iterable[str]) -> Dict[str, str]:
    """Map canonical names to actual column names present in the sheet."""
    cols = list(df_columns)
    norm_map = {c: _norm_header(c) for c in cols}
    # Inverted lookup: normalized -> original
    inv: Dict[str, str] = {v: k for k, v in norm_map.items()}

    resolved: Dict[str, str] = {}
    for key, canon in {
        "name": CANON_NAME,
        "lat": CANON_LAT,
        "lon": CANON_LON,
        "capacity": CANON_CAPACITY,
        "measurements": CANON_MEASUREMENTS,
        "notes": CANON_NOTES,
        "contact": CANON_CONTACT,
    }.items():
        norm = _norm_header(canon)
        if norm in inv:
            resolved[canon] = inv[norm]
            continue
        # try aliases
        for alias_norm, canon_target in HEADER_ALIASES.items():
            if canon_target == canon and alias_norm in inv:
                resolved[canon] = inv[alias_norm]
                break
    return resolved


def _safe_float(v: object) -> Optional[float]:
    try:
        if v is None:
            return None
        if isinstance(v, str):
            v = v.strip()
            if not v:
                return None
        f = float(v)  # type: ignore[arg-type]
        if math.isfinite(f):
            return f
        return None
    except Exception:
        return None


def _guess_lonlat_order(pair: Tuple[float, float]) -> str:
    """Return 'lonlat' if first looks like longitude, else 'latlon'."""
    a, b = pair
    if -180.0 <= a <= 180.0 and not (-90.0 <= a <= 90.0):
        return "lonlat"
    if -90.0 <= a <= 90.0 and -180.0 <= b <= 180.0:
        return "latlon"
    # Fallback to lon,lat which KML expects
    return "lonlat"


def read_polygon(polygon_path: Optional[Path]) -> Optional[List[Tuple[float, float]]]:
    if not polygon_path or not polygon_path.exists():
        return None
    pts: List[Tuple[float, float]] = []
    with polygon_path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            # Accept CSV or whitespace separated pairs
            parts = [p for p in csv.reader([line]).__next__() if p] if ("," in line) else line.split()
            if len(parts) < 2:
                continue
            a = _safe_float(parts[0])
            b = _safe_float(parts[1])
            if a is None or b is None:
                continue
            pts.append((a, b))
    if not pts:
        return None
    order = _guess_lonlat_order(pts[0])
    if order == "latlon":
        pts = [(b, a) for (a, b) in pts]
    return pts


@dataclass
class Placemark:
    name: str
    lon: float
    lat: float
    description: str = ""


def build_kml(placemarks: List[Placemark], polygon: Optional[List[Tuple[float, float]]] = None, doc_name: str = "KMZ Generated from Excel") -> str:
    """Construct a minimal KML document as a string."""
    buf = io.StringIO()
    w = buf.write
    w('<?xml version="1.0" encoding="UTF-8"?>\n')
    w('<kml xmlns="http://www.opengis.net/kml/2.2">\n')
    w("  <Document>\n")
    w(f"    <name>{doc_name}</name>\n")

    # Optional simple style for points
    w("    <Style id=\"pointStyle\">\n")
    w("      <IconStyle>\n")
    w("        <scale>1.1</scale>\n")
    w("        <Icon><href>http://maps.google.com/mapfiles/kml/paddle/red-circle.png</href></Icon>\n")
    w("      </IconStyle>\n")
    w("    </Style>\n")

    for p in placemarks:
        w("    <Placemark>\n")
        w(f"      <name>{escape_xml(p.name)}</name>\n")
        if p.description:
            w(f"      <description>{escape_xml(p.description)}</description>\n")
        w("      <styleUrl>#pointStyle</styleUrl>\n")
        w("      <Point>\n")
        w(f"        <coordinates>{p.lon},{p.lat},0</coordinates>\n")
        w("      </Point>\n")
        w("    </Placemark>\n")

    if polygon:
        # Close polygon by repeating first point if needed
        ring = list(polygon)
        if ring[0] != ring[-1]:
            ring.append(ring[0])
        coords = " ".join([f"{lon},{lat},0" for lon, lat in ring])
        w("    <Placemark>\n")
        w("      <name>Boundary Polygon</name>\n")
        w("      <Style><LineStyle><color>ff0000ff</color><width>2</width></LineStyle><PolyStyle><fill>0</fill></PolyStyle></Style>\n")
        w("      <Polygon>\n")
        w("        <outerBoundaryIs><LinearRing><coordinates>")
        w(coords)
        w("</coordinates></LinearRing></outerBoundaryIs>\n")
        w("      </Polygon>\n")
        w("    </Placemark>\n")

    w("  </Document>\n")
    w("</kml>\n")
    return buf.getvalue()


def escape_xml(text: str) -> str:
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&apos;")
    )


def excel_to_kmz(input_path: Path, output_path: Path, polygon_path: Optional[Path] = None) -> Tuple[int, Path]:
    """Convert Excel/CSV at input_path to KMZ at output_path.

    Returns: (placemark_count, output_kmz_path)
    """
    # Read table
    if input_path.suffix.lower() in {".csv"}:
        df = pd.read_csv(input_path)
    else:
        df = pd.read_excel(input_path)

    # Resolve actual column names present
    cols = resolve_columns(df.columns)
    lat_col = cols.get(CANON_LAT)
    lon_col = cols.get(CANON_LON)
    name_col = cols.get(CANON_NAME)
    capacity_col = cols.get(CANON_CAPACITY)
    meas_col = cols.get(CANON_MEASUREMENTS)
    notes_col = cols.get(CANON_NOTES)
    contact_col = cols.get(CANON_CONTACT)

    if not lat_col or not lon_col:
        raise ValueError("Latitude/Longitude columns not found in Excel")

    placemarks: List[Placemark] = []
    for _, row in df.iterrows():
        lat = _safe_float(row.get(lat_col))
        lon = _safe_float(row.get(lon_col))
        if lat is None or lon is None:
            continue
        name = str(row.get(name_col) or "Tank").strip() if name_col else "Tank"
        parts: List[str] = []
        if capacity_col and not pd.isna(row.get(capacity_col)):
            parts.append(f"Capacity: {row.get(capacity_col)}")
        if meas_col and not pd.isna(row.get(meas_col)):
            parts.append(f"Measurements: {row.get(meas_col)}")
        if contact_col and not pd.isna(row.get(contact_col)):
            parts.append(f"Contact: {row.get(contact_col)}")
        if notes_col and not pd.isna(row.get(notes_col)):
            parts.append(f"Notes: {row.get(notes_col)}")
        desc = "\n".join(parts)
        placemarks.append(Placemark(name=name or "Tank", lon=float(lon), lat=float(lat), description=desc))

    polygon = read_polygon(polygon_path)
    kml = build_kml(placemarks, polygon)

    # Ensure parent dir exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Package as KMZ
    with zipfile.ZipFile(output_path, mode="w", compression=zipfile.ZIP_DEFLATED) as zf:
        zf.writestr("doc.kml", kml)

    return len(placemarks), output_path


def main() -> int:
    p = argparse.ArgumentParser(description="Generate KMZ from Excel/CSV")
    p.add_argument("input", type=Path, help="Input Excel (.xlsx/.xls) or CSV")
    p.add_argument("-o", "--output", type=Path, required=False, help="Output KMZ path")
    p.add_argument("-p", "--polygon", type=Path, required=False, help="Optional polygon.txt path to include")
    args = p.parse_args()

    inp: Path = args.input
    if not inp.exists():
        print(f"Input not found: {inp}", file=sys.stderr)
        return 2

    if args.output is None:
        out_dir = Path("output")
        out_dir.mkdir(parents=True, exist_ok=True)
        out = out_dir / f"kmz_from_{inp.stem}.kmz"
    else:
        out = args.output

    try:
        count, path = excel_to_kmz(inp, out, args.polygon)
        print(f"KMZ written: {path} (placemarks: {count})")
        return 0
    except Exception as e:
        print(f"Failed to generate KMZ: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    raise SystemExit(main())

